### SSR
- サーバサイドレンダリング (SSR) とは? Vue.js は`クライアントサイドアプリケーション`を構築するためのフレームワーク。通常では、Vue コンポーネントは`ブラウザで DOM を生成し操作がされる`。しかし、`同じ Vue コンポーネントを`サーバ上の HTML 文字列に描画し、`ブラウザに直接送信し、最終的に静的なマークアップとしてクライアント上の完全なインタラクティブアプリケーション`に "`ハイドレート (hydrate)`" することもできる。`サーバで描画された Vue.js のアプリケーション`は、`アプリケーションのコードの大部分が、サーバとクライアントの両方で実行される`という意味で、"`アイソモーフィック (isomorphic)`" や "`ユニバーサル (universal)`" と見なすことができる。
### なぜSSR?
- 従来の SPA (シングルページアプリケーション) と比べて、SSR の利点は主に次の点にある。
1. 検索エンジンのクローラが完全に描画されたページを直接解析するため、SEO が向上: 現在のところ、Google と Bing は`同期的` JavaScript アプリケーションのインデックスを作成できる。`同期がキーワード`。アプリケーションが読み込み中にスピナが表示され、`Ajax 経由でコンテンツを取得する場合`、`クローラーは非同期結果が完了するまで待たない`。つまり、`SEO が重要なページで非同期にコンテンツを取得する場合は、SSR が必要な場合がある`
2.　特に`インターネットの遅さ`や`遅いデバイス`では、コンテンツの再生時間が短縮される`。サーバで描画されたマークアップは、すべての JavaScript がダウンロードされて表示されるまで待つ必要がない`ので、ユーザは完全に描画されたページをすぐに見ることができる。（例えば、データをリアクティブなオブジェクトに変換する前にhtmlを描画してしまうことができる）これにより、一般的にユーザーエクスペリエンスが向上し、コンテンツの所要時間が直接コンバージョン率に関連付けられているアプリケーションにとっては重要になる。
- トレードオフ
1. 開発上の制約。`ブラウザ固有のコードは、特定のライフサイクルフック内でのみでしか使用できない`。一部の外部ライブラリは、サーバで描画されたアプリケーションで実行できるように特別な処理が必要な場合がある。
2.  サーバ側の負荷が増える。 Node.js の完全なアプリケーションを描画することは、静的ファイルを提供するだけでなく、CPU を多用することになるので、トラフィックが多いことが見込まれる場合は、対応するサーバの負荷に備え、キャッシュの対策を行う。
### プリレンダリング
- もし、幾つかのマーケティングのページの SEO を向上させるためだけに SSR を調べているとしたら (たとえば /, /about, /contact など)、代わりに プリレンダリング (事前描画) を使用することを検討する方が良い。webpack を使用している場合、prerender-spa-plugin を使用することで簡単にプリレンダリングを実装することができる。
#### vue-hackernews-2.0のコードを読めばいい感じになるhttps://github.com/vuejs/vue-hackernews-2.0/tree/master/src
- `renderer` のページテンプレートに`<!--vue-ssr-outlet-->` コメントを必ずいれる。これはサーバーがアプリケーションのマークアップ（vueコンポネント、またはページごとのコンテンツ）が注入される場所。
- `context オブジェクト`も Vue アプリインスタンスと共有することができ、コンポーネントがテンプレート展開のために`データを動的に追加する`ことができる
#### 
- *.vue コンポーネントを使用する際の、`重要な CSS の自動注入`
- `clientManifest` を使用する際の、`アセットリンクとリソースヒントの自動注入`
- クライアントサイドハイドレーションのために Vuex の状態を埋め込む際に `XSS 防止の自動注入`

### サーバサイドの描画を行う上で、知っておく必要がある重要な項目
- 複数のリクエストにまたがった状態の汚染がないよう`各リクエストは新しく独立したアプリケーションのインスタンスが必要`
- `サーバー上では、データがリアクティブである必要はない`ので、デフォルトで無効になっています。データをリアクティブにしないことで、`データをリアクティブなオブジェクトに変換する際のパフォーマンスコストを無視できる`
- コンポーネントのライフサイクルフック: 動的な更新がないので、ライフサイクルフックのうち、`beforeCreate` と `created` **のみが SSR 中に呼び出される**。`beforeMount` や `mounted` などの`他のコンポーネントサイクルフック`は、**クライアントでのみ実行される**
- `beforeCreate` と `created` において、例えば `setInterval` でタイマーを設定するような、`グローバルな副作用を引き起こすコード`避けるべき。また他に、クライアントサイドのコードに限り、タイマーを設定してから `beforeDestroy` または `destroyed` 設定することができます。SSR 中に破棄フックは呼び出されないため、タイマーは実行されずに設定だけのコードが残ります。これを回避するために、代わりに`副作用コード`を `beforeMount` または `mounted` に移動してください。
### プラットフォーム固有の API にアクセス
- `ユニバーサルコード`では、プラットフォーム固有の API へのアクセスは想定されていないので、`window` や `document` `といったブラウザ環境のグローバル変数（ブラウザ API）を直接使用すると、Node.js ではエラーが発生します`
- サーバーとクライアントでコードを共有するものの、タスクが使用する API がプラットフォームによって異なる場合は、`プラットフォーム固有の実装を ユニバーサル な API の内部でラップする`か、それを行う`ライブラリを使用する`(例えば、axiosを使う（httpクライアント）)
- サードパーティライブラリが**ユニバーサルに使用することを考慮していない場合**、それをサーバサイドによって描画されるアプリケーションに統合することは難しいので注意
- `カスタムディレクティブ`: ほとんどの カスタムディレクティブ は`直接 DOM を操作するため、SSR 中にエラーが発生`します。これを回避するには、2つの方法がある。
1. 抽象化の仕組みとしてコンポーネントを使用し、カスタムディレクティブの`代わりに仮想 DOM レベル（例えば、render 関数を使用すること)で実装`する
2. コンポーネントに簡単に置き換えができないカスタムデ ィレクティブの場合、サーバーレンダラを生成する際の `directives オプションを使用`して、そのオプションの "サーバーサイドのバージョン" を用意する
- `ステートフルなシングルトンの回避`: Node.js サーバーは長時間実行されるプロセス。私たちのコードがプロセスに要求されるとき、それは`一度`**評価されメモリにとどまる**。つまり、`それはシングルトンなオブジェクトの作成で、それを全ての受信リクエスト間でシェアすると言うことである`。もし複数のリクエストをまたいでインスタンスを共有すると、それは容易にクロスリクエスト状態の汚染(cross-request state pollution)につながる -> createApp で`新しいインスタンスを作成し、ルート (root) Vue インスタンスから注入する`
### ルーティングとコード分割
#### vue-router によるルーティング
- サーバーコードが任意の URL を受け入れる * ハンドラを使用する。これにより訪れた URL を Vue アプリケーションに渡し、`クライアントとサーバーの両方に同一のルーティング設定を再利用することが可能になる`
###
- 巨大なバンドルを持つアプリケーションの `The Time to Interactive` AKA `TTI` （操作可能になるまでの時間）を大幅に改善します。重要なことは初期画面では"必要なものだけを読み込む"ということです。This measures how long it takes a page to become interactive. “`Interactive`” 
- `描画を開始する前にサーバー上のすべての非同期コンポーネントを先に解決する必要があります`。そうしなければ、マークアップ内に空のプレースホルダが表示されます。クライアント側では、`ハイドレーションを開始する前にこれを行う必要があります`。そうしなければ、クライアントはコンテンツの不一致エラーに陥ります。
- `アプリケーション内の任意の場所で非同期コンポーネントを使用するのは少し難解`です（これは将来的に改善される可能性があります）。 ただし、`ルート (route) レベルで行うとシームレスに動作します`（すなわち、ルート設定で非同期コンポーネントを使用する）必要なことは、`サーバーとクライアントの両方で` `router.onReady` を使用すること

#### ロジックとコンポーネントとの結び付き
- データをプリフェッチするアクションをディスパッチするコードはどこに置けばよいでしょうか？
- => `フェッチする必要があるデータはアクセスしたルート (route) によって決まります`。またそのルートによってどのコンポーネントが描画されるかも決まります。実のところ、`与えられたルートに必要とされるデータは、そのルートで描画されるコンポーネントに必要とされるデータでもある`のです。したがって、`データをフェッチするロジックはルートコンポーネントの中に置くのが自然`でしょう。
- コンポーネントでは、 `serverPrefetch` オプション (2.6.0 以降で新規追加)を使用します。このオプションは、`サーバレンダラ`(`vue-server-renderer`)によって認識され、そして それを返す Promise が解決されるまで描画を一時停止します。これにより、描画処理中に非同期データを"待つ"ことができます。
- `最終状態注入` : server側で、`context.rendered` でstore更新完了を待ってから、clientの方のstoreを更新する
- `ストアコードの分割`: 大規模なアプリケーションでは、Vuex ストアは複数のモジュールに分割される可能性があります。もちろん、これらのモジュールを対応するルートコンポーネントチャンクにコード分割することもできます。アプリケーションの規模が大きくなってくると、コンポネントごとにストアモジュールを分割して不要なストアは使わないと言う設計になる。各コンポネントに都度ストアのためのコード(`serverPrefetch()`, `mounted()`, 後それで使う`methods`なども一緒に)が必要になってくるからmixinとかで別に書いてくことになる。
### クライアントサイドでのハイドレーション
```js
// entry-client.js
// これは、ルート要素に id="app" をもつ App.vue テンプレートを想定します
app.$mount('#app')
```
- サーバがマークアップを描画後に、この処理を実行し、`すべての DOM を再生成することを私たちは当然したくありません`。代わりに、`静的なマークアップ`を"`ハイドレート (hydrate)`"して、それをインタラクティブな状態（`リアクティブ`と言うこと）に生成したいです。そのためには root 要素のattributeを次のように変更する。
```html
<div id="app" data-server-rendered="true">
```
### バンドルレンダラの追加
- バンドルレンダラの利点：
1. ビルトインソースマップのサポート ( webpack の設定オプションに devtool: 'source-map' を指定) (Nodejs は非サポート)
2. 開発中、デプロイ中の`ホットリロード`(シンプルに更新されたバンドルを読み込み、レンダラのインスタンス再生成)
3. `クリティカル CSS 注入` (`*.vue` ファイルを利用しているとき): `描画中に利用されるコンポーネントによって必要とされている CSS をインラインに追加`
4.　clientManifest によるアセットの注入: 自動的に最適なプリロードとプリフェッチディレクティブ、そして初期描画時に必要なコード分割チャンクを推測
### ビルド設定
- 設定ファイルを 3 つのファイル(base、client、server)に分ける
- `base 設定`: `出力パス、エイリアス、ローダーのような、client と server 両方の環境に共有される設定`を含み、`server 設定と client 設定は単純に、webpack-merge を使って、base 設定を拡張することができるもの`